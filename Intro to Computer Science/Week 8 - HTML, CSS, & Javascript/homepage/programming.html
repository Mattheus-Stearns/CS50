<!DOCTYPE html>

<html lang="en">
    <head>
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
        <link href="styles.css" rel="stylesheet">
        <script src="scripts.js"></script>
        <title>Mattheus Stearns</title>
    </head>
    <body>
		<div id="topBar">
			<div id="nav-container">
			  <div id="nav-title">Mattheus Stearns
			  </div>
			  <ul>
          <li><button onclick="location.href='index.html';" class="nav-btn">Home</button></li>
			    <li><button onclick="location.href='reading.html';" class="nav-btn">Reading</button></li>
			    <li><button onclick="location.href='writing.html';" class="nav-btn">Writing</button></li>
			    <li><button onclick="location.href='videogames.html';" class="nav-btn">Videogames</button></li>
			    <li><button onclick="location.href='programming.html';" class="nav-btn">Programming</button></li>
			  </ul>
			</div>

	    </div>
        <div id="header">
            <h1 id="main_title">Programming</h1>
            <img src="programming.jpg" alt="Programming" width=400 height=800>
        </div>
        <div id="main_wrapper"></div>

			<div id="main_contentt_transparent">
				<div id="main_content">
					<p>
                        Im submitting this as part of the cs50 course... so.. I know how to program? Do I? ehhh, no programmer <i>knows</i> how to 'program' per se,
                        they are just familiar with syntax, documentation, and stack overflow posts from a long time ago (man its been 15 years !?!?!?!?). Wait...
                        I am sounding a lot like a programmer right now aren't I? *Gulp* Let me show you some of the notes that I have for the different weeks so far...
                    </p>

                    <p>
                        By the fourth week of classes I finally started taking notes... but then the notes gradually got better as the weeks went along.
                    </p>

                    <h3>Week 3 - Notes on Algorithms</h3>

                    <p style="text-align: left;">
                        asymptotic notation: how algorithms perform over time, measuring their total efficiency<br><br>

                        selection sort<br>
                        bubble sort<br>
                        merge sort<br><br>

                        iteration<br>
                        recursion
                    </p>

                    <h3>Week 4 - Notes on Memory</h3>

                    <p style="text-align: left;">
                        & = reference operator<br>
                        * = dereference operator<br>
                        %p = pointer <br>
                        %i = int<br>
                        %c = char<br>
                        %f = float<br><br>

                        (with library) %s = string<br><br>

                        memory control with malloc and free<br>
                        garbage values<br><br>

                        A representation of computer memory: (from top to bottom)<br><br>

                        --------------------------<br>
                              Machine Code      <br>
                        --------------------------<br>
                                 Globals        <br>
                        --------------------------<br>
                                  Heap          <br>
                                   |            <br>
                                   V            <br>
                                                <br>
                                                <br>
                                                <br>
                                   ^            <br>
                                   |            <br>
                                 Stack          <br>
                        --------------------------<br><br>

                        As you can see from this model, both the heap and the stack point to each other. This can create problems of:<br><br>

                        - Stack overflow<br>
                        - Heap overflow<br><br>

                        ... Examples of buffer overflow.<br><br>

                        => this was what happened with croudstrike
                    </p>

                    <h3>Week 5 - Notes on Data Structures</h3>

                    <p style="text-align: left;">
                        data structures<br>
                        abstract data types<br><br>

                        queues<br>
                        FIFO: First in First out<br><br>

                        enqueue<br>
                        dequeue<br><br>

                        in code:-<br><br>

                        const int CAPACITY = 50;<br><br>

                        typedef struct<br>
                        {<br>
                            person people[CAPACITY];<br>
                            int size;<br>
                        } queue;<br><br>

                        stacks<br>
                        LIFO: Last in First Out<br><br>

                        push<br>
                        pop<br><br>

                        in code:-<br><br>

                        const int CAPACITY = 50;<br><br>

                        typedef struct<br>
                        {<br>
                            person people[CAPACITY];<br>
                            int size;<br>
                        } stack;<br><br>

                        data structures:<br>
                        struct<br>
                        .<br>
                        *<br>
                        -><br><br>

                        linked lists<br>
                        - value<br>
                        - pointer<br><br>

                        in code:-<br><br>

                        typedef struct node<br>
                        {<br>
                            int number;<br>
                            struct node *next;<br>
                        } node;<br><br>

                        with linked lists:<br>
                        - there are stacked lists<br>
                        - there are FIFO lists<br>
                        - you can also have lists that in the process of becoming a linked list get sorted, or, are already sorted before and then can add new variables in the middle of <br>
                        the linked list that conform to how you have sorted the list -- this is shown in list8.c<br><br>

                        there exists a data struct: Trees<br>
                        more specifically, binary search trees<br>
                        its a linked list that has two dimensions, or two pointers attached to each variable, allowing for binary search<br><br>

                        in code:-<br><br>

                        typedef struct node<br>
                        {<br>
                            int number;<br>
                            struct node *left;<br>
                            struct node *right;<br>
                        } node;<br><br>

                        Here is how you would search such a tree, in code:-<br><br>

                        bool search(node *tree; int number)<br>
                        {<br>
                            if (tree == NULL)<br>
                            {<br>
                                return false;<br>
                            }<br>
                            else if (number < tree->number)<br>
                            {<br>
                                return search(tree->left, number);<br>
                            }<br>
                            else if (number > tree->number)<br>
                            {<br>
                                return search(tree->right, number);<br>
                            }<br>
                            else<br>
                            {<br>
                                return true;<br>
                            }<br>
                        }<br><br>

                        The problem is that trees could in the worst case scenario turn into linked lists if they are not balanced<br>
                        the best case scenario, is obviously O(logn) because the height of a balanced tree is O(logn)<br>
                        but if it doesnt then it devolves into O(n)<br><br>

                        dictionaries<br>
                        keys<->values<br><br>

                        Holy grail: O(1), or constant time<br>
                        this can be done through.... hashing!<br><br>

                        hash functions: a method to quantize things by group, reducing a large domain into a small amount of things and much easier to manipulate<br>
                        hash tables: built with hash functions<br><br>

                        hash tables can be an array of linked lists<br><br>

                        Progression from phonebook struct to this hash table in code:-<br><br>

                        typedef struct<br>
                        {<br>
                            char *name;<br>
                            char *person;<br>
                        } person;<br><br>

                        to<br><br>

                        typedef struct node<br>
                        {
                            char *name;<br>
                            char *number;<br>
                            struct node *next; // essentially including a linked list into the phonebook struct<br>
                        } node;<br><br>

                        instead of looking at the first character, you could always just look at the first three characters (as an example)<br>
                        but, looking at more than the first character, you will run into many cases that wont ever be used, and its just going to take up lots of space fast<br>
                        so we use only the first character<br><br>

                        For example, in code:-<br><br>

                        unsigned int hash(char *word)<br>
                        {<br>
                            return toupper(word[0]) - 'A'<br>
                        }<br><br>

                        The advantage of hash tables is that they are O(n/k), where k is your number of buckets<br><br>

                        indeed, you can come up with or find a hash function that will be best suited for your situation, and that will keep you as close to O(1) as possible<br>
                        shows the importance of a good, relevant hash function<br><br>

                        There also exists: tries<br>
                        a trie, is a data structure that is a tree of arrays<br>
                        this allows it to be, by definition, O(1) and operating in constant time<br><br>

                        in code:-<br><br>

                        typedef struct node<br>
                        {<br>
                            struct node *children[26];<br>
                            char *number;<br>
                        } node;<br><br>

                        The big tradeoff in the room: massively using memory to gain increase in time efficiency
                    </p>
                    <h5>(skipped taking notes on Python Programming due to my fluency)</h5>
                    <h3>Week 7 - Notes on SQL</h3>
                    <p style="text-align: left;">
                        Flat-File Database<br>
                        -> (CSV): i.e., a simple database that holds data with columns and rows<br><br> 

                        CREATE TABLE IF NOT EXISTS table_name (<br>
                            column1 datatype PRIMARY KEY,<br>
                            column2 datatype,<br>
                            column3 datatype,<br>
                            ...<br>
                        );<br><br>

                        CREATE INDEX index_name<br>
                        ON table_name (column1, column2, ...);<br><br>

                        INSERT INTO table_name (column1, column2, column3, ...)<br>
                        VALUES (value1, value2, value3, ...);<br><br>

                        SELECT column1, column2, ...<br>
                        FROM table_name<br>
                        WHERE condition<br>
                        GROUP BY column<br>
                        ORDER BY column<br>
                        LIMIT number;<br><br>

                        DELETE FROM table_name<br>
                        WHERE condition;<br><br>

                        UPDATE table_name<br>
                        SET column1 = value1, column2 = value2, ...<br>
                        WHERE condition;<br><br>

                        Relational Database<br>
                        Master-File: A file which has a lot of id's and establishes the relationship between them<br>
                        Definintion File: A file which has a lot of id's tied to their real life values, establishing the entities that they are <br><br>

                        one-to-one relationship: i.e. one show has one rating<br>
                        one-to-many relationships: i.e. one show in multiple genres<br>
                        many-to-many relationships: i.e. one show with many actors, and one actor in many shows<br>
                        primary key: unique identifier<br><br>

                        CREATE TABLE shows (<br>
                            id INTEGER,<br>
                            title TEXT NOT NULL,<br>
                            year NUMERIC,<br>
                            episodes INTEGER,<br>
                            PRIMARY KEY(id)<br>
                        );<br><br>

                        CREATE TABLE ratings (<br>
                            show_id INTEGER NOT NULL,<br>
                            rating REAL NOT NULL,<br>
                            votes INTEGER NOT NULL,<br>
                            FOREIGN KEY(show_id) REFERENCES shows(id)<br>
                        );<br><br>

                        See how they are related? "PRIMARY KEY(id)" and "FOREIGN KEY(show_id) REFERENCES shows(id)"?<br><br>

                        Data Types<br><br>

                        BLOB<br>
                        INTEGER<br>
                        NUMERIC<br>
                        REAL<br>
                        TEXT<br><br>

                        Keywords<br><br>

                        NOT NULL<br>
                        UNIQUE<br><br>

                        PRIMARY KEY<br>
                        FOREIGN KEY<br><br>

                        Indexing exists to speed up the time taken for specific queries<br><br>

                        Trade-off: B-trees<br><br>

                        Race Conditions: When there are many requests simultanueosly to the same database, to change the same value, there can be issues.<br>
                        How do you handle this issue?<br><br>

                        BEGIN TRANSACTION<br>
                        COMMIT<br>
                        ROLLBACK<br><br>

                        Example:<br><br>

                        db.execute("BEGIN TRANSACTION")<br>
                        rows = db.execute("SELECT likes FROM posts WHERE id = ?", id);<br>
                        likes = rows[0]["likes"]<br>
                        db.execute("UPDATE posts SET likes = ? WHERE id = ?", likes + 1, id);<br>
                        db.execute("COMMIT")<br><br>

                        SQL Injection Attacks / Prompt Injection Attacks: Injecting code into the database / into AI models that at best resulted from a mistake but could be malicious<br><br>

                        Example:<br><br>

                        Email Address = malan@harvard.edu'--<br><br>

                        Code =><br><br>

                        rows = db.execute(f"SELECT * FROM users WHERE username = '{username}' AND password = '{password}'")<br><br>

                        if rows:<br>
                            ...<br>
                            <br>
                        This would effectively comment the password part of the SQL, allowing users to get in with just an existing email address<br><br>

                        SOLUTION:<br><br>

                        rows = db.execute("SELECT * FROM users WHERE username = ? AND password = ?", username, password)
                    </p>
				</div>
			</div>
		</div>
       
	</body>

</html>
